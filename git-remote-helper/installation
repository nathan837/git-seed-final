#!/bin/bash
# install-ipfs-git-helper.sh

echo "Installing IPFS Git remote helper..."

# Create the helper directory
mkdir -p ~/.git-ipfs-helper

# Save the Python script
cat > ~/.git-ipfs-helper/ipfs-remote-helper.py << 'EOF'
#!/usr/bin/env python3
"""
Git remote helper for IPFS (InterPlanetary File System)
Allows pushing to and cloning from IPFS repositories
"""

import os
import sys
import json
import subprocess
import tempfile
import shutil
from pathlib import Path
from typing import Dict, List, Optional, Tuple

class IPFSRemoteHelper:
    def __init__(self):
        self.repo_path = None
        self.remote_url = None
        self.capabilities = ['connect', 'stateless-connect', 'push', 'fetch']

    def run_ipfs_command(self, args: List[str]) -> str:
        """Run an IPFS command and return the output"""
        try:
            result = subprocess.run(['ipfs'] + args,
                                  capture_output=True,
                                  text=True,
                                  check=True)
            return result.stdout.strip()
        except subprocess.CalledProcessError as e:
            print(f"IPFS command failed: {e}", file=sys.stderr)
            raise

    def add_to_ipfs(self, path: str) -> str:
        """Add directory or file to IPFS and return CID"""
        return self.run_ipfs_command(['add', '-r', '-Q', path])

    def get_from_ipfs(self, cid: str, output_path: str) -> None:
        """Get content from IPFS by CID"""
        self.run_ipfs_command(['get', '-o', output_path, cid])

    def parse_remote_url(self, url: str) -> str:
        """Parse IPFS remote URL and return CID"""
        if url.startswith('ipfs://'):
            return url[7:]  # Remove 'ipfs://' prefix
        elif url.startswith('ipns://'):
            # Resolve IPNS name to CID
            ipns_name = url[7:]
            return self.run_ipfs_command(['name', 'resolve', ipns_name])
        else:
            return url  # Assume it's already a CID

    def handle_capabilities(self) -> None:
        """Respond with supported capabilities"""
        print(' '.join(self.capabilities))
        print()
        sys.stdout.flush()

    def handle_connect(self, service: str, remote_url: str) -> None:
        """Handle connect command"""
        try:
            cid = self.parse_remote_url(remote_url)

            if service == 'git-receive-pack':
                # For push operations
                with tempfile.TemporaryDirectory() as temp_dir:
                    # Get the remote repository
                    self.get_from_ipfs(cid, temp_dir)

                    # Start git-receive-pack in the temp directory
                    cmd = ['git-receive-pack', temp_dir]
                    proc = subprocess.Popen(cmd, stdin=sys.stdin, stdout=sys.stdout)
                    proc.wait()

            elif service == 'git-upload-pack':
                # For fetch operations
                with tempfile.TemporaryDirectory() as temp_dir:
                    self.get_from_ipfs(cid, temp_dir)

                    cmd = ['git-upload-pack', temp_dir]
                    proc = subprocess.Popen(cmd, stdin=sys.stdin, stdout=sys.stdout)
                    proc.wait()

        except Exception as e:
            print(f"Error in connect: {e}", file=sys.stderr)
            sys.exit(1)

    def handle_push(self, local_ref: str, remote_ref: str) -> None:
        """Handle push command"""
        try:
            # Create a bundle of the current state
            with tempfile.TemporaryDirectory() as temp_dir:
                # Create bundle
                bundle_file = os.path.join(temp_dir, 'bundle')
                subprocess.run(['git', 'bundle', 'create', bundle_file, '--all'],
                             check=True, cwd=self.repo_path)

                # Add to IPFS
                cid = self.add_to_ipfs(bundle_file)
                print(f"Pushed to IPFS: ipfs://{cid}")

        except Exception as e:
            print(f"Error in push: {e}", file=sys.stderr)
            sys.exit(1)

    def handle_fetch(self, cid: str) -> None:
        """Handle fetch command"""
        try:
            with tempfile.TemporaryDirectory() as temp_dir:
                # Get bundle from IPFS
                bundle_file = os.path.join(temp_dir, 'bundle')
                self.get_from_ipfs(cid, bundle_file)

                # Verify it's a valid bundle
                if not os.path.exists(bundle_file):
                    raise Exception("Failed to fetch bundle from IPFS")

                # Import bundle into current repository
                subprocess.run(['git', 'bundle', 'unbundle', bundle_file],
                             check=True, cwd=self.repo_path)

        except Exception as e:
            print(f"Error in fetch: {e}", file=sys.stderr)
            sys.exit(1)

    def process_command(self, line: str) -> None:
        """Process a single command from git"""
        parts = line.strip().split()
        if not parts:
            return

        command = parts[0]

        if command == 'capabilities':
            self.handle_capabilities()

        elif command == 'connect':
            if len(parts) < 3:
                print("Invalid connect command", file=sys.stderr)
                return
            service, remote_url = parts[1], parts[2]
            self.handle_connect(service, remote_url)

        elif command == 'push':
            if len(parts) < 3:
                print("Invalid push command", file=sys.stderr)
                return
            local_ref, remote_url = parts[1], parts[2]
            self.remote_url = remote_url
            self.handle_push(local_ref, remote_url)

        elif command == 'fetch':
            if len(parts) < 2:
                print("Invalid fetch command", file=sys.stderr)
                return
            cid = parts[1]
            self.handle_fetch(cid)

        else:
            print(f"Unknown command: {command}", file=sys.stderr)

    def main(self):
        """Main entry point"""
        # Read repo path from environment
        self.repo_path = os.getcwd()

        # Process commands from stdin
        try:
            while True:
                line = sys.stdin.readline()
                if not line:
                    break
                self.process_command(line)
        except KeyboardInterrupt:
            pass
        except Exception as e:
            print(f"Error: {e}", file=sys.stderr)
            sys.exit(1)

def main():
    """Main function"""
    helper = IPFSRemoteHelper()
    helper.main()

if __name__ == '__main__':
    main()
EOF

chmod +x ~/.git-ipfs-helper/ipfs-remote-helper.py

# Add to git config
git config --global credential.helper ""
git config --global protocol.ipfs.allow always

echo "Installation complete!"
echo "Make sure IPFS is installed and running: ipfs daemon"